# This code has been adapted from the wrsk package ((Brodinova et al (2017))
GenSynData<- function(size_clusters,
                      p_inf,
                      p_noise,
                      mu_clusters,
                      s_clusters,
                      out_unif_range,
                      out_n,
                      out_p) {
  n_clusters <- length(size_clusters)
  
  # pattern "mu followed by (n_clusters-1) zeros" across the variables
  # caluculate center of clusters
  if (p_inf == 2) {
    MU_clusters <- matrix(0, nrow=p_inf+1, ncol=n_clusters)
    diag(MU_clusters) <- mu_clusters
    MU_clusters <- MU_clusters[1:2,]
  } else {
    n_p <- floor(p_inf/n_clusters)
    MU_clusters <-  matrix(nrow=0, ncol=n_clusters)
    for (i in 1:n_p) {
      MU_clusters <- rbind(matrix(0, nrow=n_clusters, ncol=n_clusters), MU_clusters)
      diag(MU_clusters) <- mu_clusters
    }
    if (nrow(MU_clusters) != p_inf) {
      for(i in 1:(p_inf - nrow(MU_clusters))){
        mi <- rep(0, n_clusters)
        mi[i] <- mu_clusters[i]
        MU_clusters <- rbind(MU_clusters, mi)
      }
    }
  }
  
  # # mu for the first part and 0 for the second part of the variables
  # # caluculate center of clusters for informative variables
  # # experiments have been done and shown same effect as the above procedure
  # stride <- ceiling(p_inf/n_clusters)
  # MU_clusters <- matrix(0, nrow=p_inf, ncol=n_clusters)
  #
  # nth <- 1
  # beg <- 1
  # while (nth < n_clusters + 1) {
  #   end <- min(beg + stride - 1, p_inf)
  #   MU_clusters[beg:end, nth] <- mu_clusters[nth]
  #
  #   nth <- nth + 1
  #   beg <- end + 1
  # }
  
  # generate data
  mu_out <- MU_clusters
  n <- sum(size_clusters)
  p <- ifelse(is.null(p_noise), p_inf, p_inf + p_noise)
  lb1 <- vector(length=0)
  y <- vector(length=0)
  x <- matrix(nrow=0, ncol=p)
  
  for(i in 1:n_clusters){
    lb <- c(rep(i, size_clusters[i]))
    y <- c(y, rep(i, size_clusters[i]))
    S_clusters <- s_clusters[[i]]
    
    # inf variables
    X <- MASS::mvrnorm(size_clusters[i], mu=MU_clusters[,i], Sigma=S_clusters)
    
    # noise variables
    if(!is.null(p_noise)){
      X <- cbind(X, matrix(rnorm(p_noise*size_clusters[i], mean=0), ncol=p_noise))
    }
    
    # generate outliers
    if (out_n[i] != 0) {
      if (is.null(out_p)) {
        p_out <- 1:p
      } else {
        p_out <- sample(1:p, out_p)
      }
      
      o_out <- 1:out_n[i]
      
      # assign uniform outliers
      X[o_out, p_out] <- matrix(runif(length(o_out)*length(p_out),
                                      min=out_unif_range$min, max=out_unif_range$max),
                                nrow=length(o_out), ncol=length(p_out))
      lb[o_out] <- 0
    }
    
    x <- rbind(x, X)
    lb1 <- c(lb1, lb)
  }
  
  colnames(x) <- paste0("x", rep(1:p))
  rownames(x) <- paste0("s", rep(1:n))
  names(y) <- paste0("s", rep(1:n))
  names(lb1) <- paste0("s", rep(1:n))
  return(list(x=x, y=y, lb=lb1))
  # x ... a data set
  # y ... cluster membership before contamination
  # lb ... cluster and outlier membership
}


# This function generates a synthetic dataset for the purpose of data clustering
# in case of both outliers and noise variables are present.
#
# size_clusters:  a vector containing the cluster sizes to be generated. The length of the vector corresponds to the number of clusters to be generated. The default is c(40, 40, 40).
# p_inf:          number of informative variables describing the generated cluster structure. The default is 50.
# p_noise:        number of noise variables which do not contribute to the cluster separation. The default is 950.
# mu:             numeric number used for generating the mean of multivariate Gaussian distributions of clusters. The default is 2.
# rho_unif_range: interval used for generating covariance matrice of multivariate Gaussian distributions of clusters. The default is {list(min=0.1, max=0.9)}.
# out_pct:        proportion of outliers. The default is 0.
# out_p:          number of variables whose values are replaced by uniformly distributed numbers for outliers. The default is 50.
# out_unif_range: interval of uniform distribution for outliers. The default is {list(min=-6, max=6)}.
# iseed:          seed of random number generator. The default is NULL.
#
# Clusters are generated in the first {p_inf} informative variables with various characteristics following Gaussian models.
# The clusters have different mean vectors and covariance matrix which is additionally randomly rotated.
# Noise variables are generated following standard normal distributions.
# Outliers are optionally generated by randomly choosing informative & noise variables and replacing them with uniformly distributed numbers.
#
# output (list)
# x:  data matrix of the synthetic dataset.
# y:  integer vector corresponding to the cluster membership.
# lb: if the input out_pct > 0, lb is outputted as an integer vector with cluster lables and outlier label (denoted as 0) after outlier contamination.
#
# # example
# # Generate 3 clusters of equal sizes in the first 50 informative variables
# # with 950 noise variables and 10% of uniformly distributed outliers in 50 variables.
#
# source(system.file("scripts", "gen_sim_data.R", package = "recombine"))
# d <- gen_sim_data(iseed = 1)
# table(d$lb)
#
gen_sim_data <- function(size_clusters = c(40, 40, 40),
                         p_inf = 50,
                         p_noise = 950,
                         mu = 2,
                         rho_unif_range = list(min=0.1, max=0.9),
                         out_pct = 0,
                         out_p = 50,
                         out_unif_range = list(min=-6, max=6),
                         iseed = NULL) {
  for (pkg in c("mixAK", "MASS")) {
    if (!nzchar(system.file(package = pkg))) stop(paste0("Error: ", pkg, " is required but not installed."))
  }
  
  if (!is.null(iseed)) {
    set.seed(iseed)
  }
  
  # clusters
  n_clusters <- length(size_clusters)
  mu_clusters <- rep(mu, n_clusters)
  ss_clusters <- rep(1, n_clusters)
  rrho_clusters <- runif(n_clusters, min=rho_unif_range$min, max=rho_unif_range$max)
  
  if (n_clusters < 2) stop("n_clusters needs >= 2")
  if (p_inf < 2) stop("p_inf needs >= 2")
  
  # cluster covariance structure
  s_clusters <- list()
  for(j in 1:n_clusters){
    S_g <- matrix(rrho_clusters[j], ncol=p_inf, nrow=p_inf)
    diag(S_g) <- ss_clusters[j]
    R <- mixAK::rRotationMatrix(n=1, dim=p_inf)
    
    s_clusters[[j]] <- R %*% S_g %*% t(R)
  }
  
  # number of outliers
  out_n <- c(round(size_clusters*out_pct))
  
  # generate
  ds <- GenSynData(size_clusters,
                   p_inf,
                   p_noise,
                   mu_clusters,
                   s_clusters,
                   out_unif_range,
                   out_n,
                   out_p)

  if (out_pct == 0) ds$lb <- NULL  
  return(ds)
}

