% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fl.R
\name{SHC_FL_gapstat}
\alias{SHC_FL_gapstat}
\title{SHC_FL_gapstat}
\usage{
SHC_FL_gapstat(
  x,
  lambda1s = NULL,
  lambda2s = NULL,
  standardize.arrays = FALSE,
  dissimilarity = c("squared.distance", "absolute.value"),
  method = c("average", "complete", "single", "centroid", "ward.D", "ward.D2",
    "mcquitty", "median"),
  max.iter = 100,
  iseed = NULL,
  silent = FALSE,
  return_all_results = FALSE,
  nperms = 10,
  sel_rule = c("max", "1se.rule")
)
}
\arguments{
\item{x}{data matrix. Rows are samples, while columns are features.}

\item{lambda1s}{sparsity parameters. If Null, lambda1s is assigned as \code{seq(1, max(nrow(x), ncol(x)), length = 10)}. The default is NULL.}

\item{lambda2s}{successive difference sparsity parameters. If Null, lambda2s is assigned as \code{seq(1, max(nrow(x), ncol(x)), length = 10)}. The default is NULL.}

\item{standardize.arrays}{should the data matrix be standardized? The default is FALSE.}

\item{dissimilarity}{type of dissimilarity metric. This should be either "squared.distance" or "absolute.value". The default is "squared.distance".}

\item{method}{the agglomeration method to be used. This should be (an unambiguous abbreviation of) one of "ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC). The default is "average".}

\item{max.iter}{maximum number of iterations. The default is 500.}

\item{iseed}{seed of random numbers used for initializing w. If Null, all elements of w are initialized as a fixed value of 1.0/sqrt(p). Otherwise, the initial w elements are uniformly distributed in \code{[0, 2.0/sqrt(p)]}. The default is NULL.}

\item{silent}{should progress messages be suppressed? The default is FALSE.}

\item{return_all_results}{should SHC_FL results for all hyperparameters be returned? If False, only the result for the best hyperparameter is returned. The default is FALSE.}

\item{nperms}{number of permutations. The default is 10.}

\item{sel_rule}{rule for choosing the best hyperparameter. This should be either "max" (maximum gap statistic) or "1se.rule" (having a low complexity but within 1 standard error of the maximum gap statistic). The default is "max".}
}
\value{
\item{lassotype}{abbreviated name of lasso type.}
\item{lassotype_full}{full name of lasso type.}
\item{tots}{the strength of the clustering using real data (i.e., maximized objective function values).}
\item{permtots}{the strength of the clustering using permuted data (i.e., maximized objective function values).}
\item{w_l0norm}{L0 norm of w.}
\item{gaps_mean}{mean values of gap statistic.}
\item{gaps_se}{standard errors of gap statistic.}
\item{hyp1s}{hyperparameters lambda1's.}
\item{hyp2s}{hyperparameters lambda2's.}
\item{best_hyp1}{best hyperparameter lambda1.}
\item{best_hyp2}{best hyperparameter lambda2.}
\item{best_index}{index of best hyperparameter (i.e., the optimal pair of lambda1 and lambda2). The pairs are stored in a 1-dimensional vector, with a lambda1-major order.}
\item{result}{SHC_FL result. If return_all_results is TRUE, results of all hyperparameters are stored as a list, in which each element is a result of SHC_FL; otherwise, it only contains the result corresponding to the best hyperparameter.}
}
\description{
This function computes gap statistic profile for a series of hyperparameters (lambda1's and lambda2's) by running SHC_FL on both original data and permuted data.
}
\details{
For a hyperparameter, the gap statistic measures the strength of the clustering based on real data with respect to the one based on randomly permuted data that are supposed to have no cluster.
This function runs SHC_FL for every hyperparameter (i.e., a pair of lambda1 and lambda2), calculates gap statistic, and get the best hyperparamter that corresponds to the maximum gap statistic.
}
\examples{
d <- example_sim_data

# reorder features based on generative process
order <- c()
for (i in 1:n_clusters) {
  order <- c(order, seq(from = i, to = p_inf, by = n_clusters))
}
order <- c(order, (p_inf+1):p)

mt <- d$x[, order]

# to save time, run a 5-by-5 grid search; 
# in practice, a more refined grid search may be performed.
out <- SHC_FL_gapstat(d$x,
                      lambda1s = seq(0, 0.5*max(nrow(mt), ncol(mt)), length = 5),
                      lambda2s = seq(1, 10*max(nrow(mt), ncol(mt)), length = 5),
                      nperms = 3)
out

}
